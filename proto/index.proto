// Copyright (c) 2023 dingodb.com, Inc. All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

import "common.proto";
import "error.proto";
import "store.proto";

package dingodb.pb.index;

option java_package = "io.dingodb.index";
option cc_generic_services = true;

message VectorAddRequest {
  uint64 region_id = 1;
  repeated dingodb.pb.common.VectorWithId vectors = 2;
  bool replace_deleted = 3;
  bool is_update = 4;
}

message VectorAddResponse {
  dingodb.pb.error.Error error = 1;
  // return the execution status of each key
  // key_states[index] = true, add success
  // key_states[index] = false, add failed
  repeated bool key_states = 2;
}

message VectorBatchQueryRequest {
  uint64 region_id = 1;
  repeated uint64 vector_ids = 2;
  bool without_vector_data = 3;       // Default false, if true, response without vector data.
  bool with_scalar_data = 4;          // Default false, if true, response with scalar data.
  repeated string selected_keys = 5;  // If with_scalar_data is true, selected_keys is used to select scalar data, if
                                      // this parameter is null, all scalar data will be returned.
  bool with_table_data = 6;           // Default false, if true, response with table data.
}

message VectorBatchQueryResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithId vectors = 2;
}

message VectorScanQueryRequest {
  uint64 region_id = 1;
  uint64 vector_id_start = 2;
  bool is_reverse_scan = 3;
  uint64 max_scan_count = 4;  // the max count user want to scan
  uint64 vector_id_end = 5;   // the end id of scan, if is_reverse_scan is true, vector_id_end must be less than
                              // vector_id_start, if is_reverse_scan is false, vector_id_end must be greater than
                              // vector_id_start
                              // the real range is [start, end], include start and end
                              // if vector_id_end == 0, scan to the end of the region

  bool without_vector_data = 11;       // Default false, if true, response without vector data.
  bool with_scalar_data = 12;          // Default false, if true, response with scalar data.
  repeated string selected_keys = 13;  // If with_scalar_data is true, selected_keys is used to select scalar data, if
                                       // this parameter is null, all scalar data will be returned.
  bool with_table_data = 14;           // Default false, if true, response with table data.

  // Whether to use scalar filtering.
  bool use_scalar_filter = 20;
  dingodb.pb.common.VectorScalardata scalar_for_filter = 21;
}

message VectorScanQueryResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithId vectors = 2;
}

message VectorGetRegionMetricsRequest {
  uint64 region_id = 1;
}

message VectorGetRegionMetricsResponse {
  dingodb.pb.error.Error error = 1;
  dingodb.pb.common.VectorIndexMetrics metrics = 2;
}

// vector.id > 0: exact query
// vector.id == 0: similarity search with vector.vector
message VectorSearchRequest {
  uint64 region_id = 1;
  dingodb.pb.common.VectorWithId vector = 2;
  dingodb.pb.common.VectorSearchParameter parameter = 3;
  repeated dingodb.pb.common.VectorWithId vector_with_ids = 4;  // this field is used for batch search
}

message VectorWithDistanceResult {
  repeated dingodb.pb.common.VectorWithDistance vector_with_distances = 1;
}

message VectorSearchResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithDistance results = 2;
  repeated VectorWithDistanceResult batch_results = 3;  // this field is used for batch search
}

message VectorDeleteRequest {
  uint64 region_id = 1;
  repeated uint64 ids = 2;
}

message VectorDeleteResponse {
  dingodb.pb.error.Error error = 1;
  // return the execution status of each key
  // key_states[index] = true, delete success
  // key_states[index] = false, key not exist
  repeated bool key_states = 2;
}

message VectorGetBorderIdRequest {
  uint64 region_id = 1;
  bool get_min = 2;  // if true, get min id, else get max id
}

message VectorGetBorderIdResponse {
  dingodb.pb.error.Error error = 1;
  uint64 id = 2;
}

enum AlgorithmType {
  ALGORITHM_NONE = 0;
  ALGORITHM_FAISS = 1;
  ALGORITHM_HNSWLIB = 2;
}

message VectorCalcDistanceRequest {
  // which library algorithm to use
  AlgorithmType algorithm_type = 1;

  // must be valid
  dingodb.pb.common.MetricType metric_type = 2;

  // target vector arrays . empty do nothing. no error.
  repeated dingodb.pb.common.Vector op_left_vectors = 3;

  // source vector arrays . empty do nothing. no error.
  repeated dingodb.pb.common.Vector op_right_vectors = 4;

  // whether to return the normalized result.
  bool is_return_normlize = 5;
}

message VectorDistance {
  repeated float internal_distances = 1;
}

message VectorCalcDistanceResponse {
  dingodb.pb.error.Error error = 1;

  // return normalized result if is_return_normlize is true
  repeated dingodb.pb.common.Vector op_left_vectors = 2;

  // return normalized result if is_return_normlize is true
  repeated dingodb.pb.common.Vector op_right_vectors = 3;

  // num distance values = op_left_vectors *  op_right_vectors
  repeated VectorDistance distances = 4;
}

// vector.id > 0: exact query
// vector.id == 0: similarity search with vector.vector
message VectorSearchDebugRequest {
  uint64 region_id = 1;
  dingodb.pb.common.VectorWithId vector = 2;
  dingodb.pb.common.VectorSearchParameter parameter = 3;
  repeated dingodb.pb.common.VectorWithId vector_with_ids = 4;  // this field is used for batch search
}

message VectorSearchDebugResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithDistance results = 2;
  repeated VectorWithDistanceResult batch_results = 3;  // this field is used for batch search

  // scalar scan time unit  microsecond 10 -6 s
  int64 deserialization_id_time_us = 4;

  // scalar scan time unit  microsecond 10 -6 s
  int64 scan_scalar_time_us = 5;

  // search  vector unit  microsecond 10 -6 s
  int64 search_time_us = 6;
}

// TxnKvGet do point-lookup a value for key in the transaction with start_ts
message TxnGetRequest {
  dingodb.pb.store.Context context = 1;
  bytes key = 2;  // the key is encoded from two uint64 using big-endian, the first uint64 is the part id, the second
                  // uint64 is the vector id. The key MUST be 16 bytes.
  uint64 start_ts = 3;

  // the parameter below is inherited from VectorBatchQueryRequest
  bool without_vector_data = 11;       // Default false, if true, response without vector data.
  bool with_scalar_data = 12;          // Default false, if true, response with scalar data.
  repeated string selected_keys = 13;  // If with_scalar_data is true, selected_keys is used to select scalar data, if
                                       // this parameter is null, all scalar data will be returned.
  bool with_table_data = 14;           // Default false, if true, response with table data.
}

message TxnGetResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  // The vector value associated with the key, if not found, is empty and error is NOT_FOUND
  dingodb.pb.common.VectorWithId vectors = 3;
  // True if the key does not exist in the database.
  bool not_found = 4;
}

// TxnKvScan fetches values for a range of keys in the transaction with start_ts.
message TxnScanRequest {
  dingodb.pb.store.Context context = 1;
  // the real Range is [start_key, end_key) or [end_key, start_key)
  bytes start_key = 2;  // the key is encoded from two uint64 using big-endian, the first uint64 is the part id, the
                        // second uint64 is the vector id. The key MUST be 16 bytes.
  bytes end_key = 3;    // the key is encoded from two uint64 using big-endian, the first uint64 is the part id, the
                        // second uint64 is the vector id. The key MUST be 16 bytes.
  // The maximum number of results to return.
  uint32 limit = 4;
  uint64 start_ts = 5;
  // Return only the keys found by scanning, not their values.
  bool key_only = 6;  // this means on return vector id in the resposne
  // For compatibility, when scanning forward, the range to scan is [start_key, end_key), where start_key < end_key;
  // and when scanning backward, it scans [end_key, start_key) in descending order, where end_key < start_key.
  bool is_reverse = 7;

  // the parameter below is inherited from VectorBatchQueryRequest
  bool without_vector_data = 11;       // Default false, if true, response without vector data.
  bool with_scalar_data = 12;          // Default false, if true, response with scalar data.
  repeated string selected_keys = 13;  // If with_scalar_data is true, selected_keys is used to select scalar data, if
                                       // this parameter is null, all scalar data will be returned.
  bool with_table_data = 14;           // Default false, if true, response with table data.
}

enum Op {
  None = 0;      // just a placeholder
  Put = 1;       // same as VectorAdd, it means upsert
  Delete = 2;    // same as VectorDelete
  Lock = 3;      // not used now
  Rollback = 4;  // only do rollback
}

message Mutation {
  Op op = 1;
  bytes key = 2;  // the key is encoded from two uint64 using big-endian, the first uint64 is the part id, the second
                  // uint64 is the vector id. The key MUST be 16 bytes.
  dingodb.pb.common.VectorWithId vector = 3;
}

// if some key is lock by other txn, the scan will failed with error LOCKED, kvs is empty
// client must retry the scan request
message TxnScanResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  repeated dingodb.pb.common.VectorWithId vectors = 3;
}

message TxnPrewriteRequest {
  dingodb.pb.store.Context context = 1;
  // The data to be written to the database.
  repeated Mutation mutations = 2;
  // The primary lock of the transaction is setup by client
  bytes primary_lock = 3;
  // Identifies the transaction being written.
  uint64 start_ts = 4;
  // the lock's time to live in milliseconds
  uint64 lock_ttl = 5;
  // the number of keys involved in the transaction
  uint64 txn_size = 6;
}

message TxnPrewriteResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
}

message TxnCommitRequest {
  dingodb.pb.store.Context context = 1;
  // The start_ts of the transaction.
  uint64 start_ts = 2;
  // The commit_ts of transaction. Must be greater than `start_ts`.
  uint64 commit_ts = 3;
  // All keys in the transaction to be committed.
  repeated bytes keys = 4;
}

message TxnCommitResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  uint64 commit_ts = 3;
}

// CheckTxnStatusRequest checks the status of a transaction.
// If the transaction is rollbacked/committed, return that result.
// If the TTL of the transaction is exhausted, abort that transaction and inform the caller.
// Otherwise, returns the TTL information for the transaction.
message TxnCheckTxnStatusRequest {
  dingodb.pb.store.Context context = 1;
  // Primary key and lock ts together to locate the primary lock of a transaction.
  bytes primary_key = 2;
  // Starting timestamp of the transaction being checked.
  uint64 lock_ts = 3;
  // The start timestamp of the transaction which this request is part of.
  uint64 caller_start_ts = 4;
  // The client must specify the current time to dingo-store using this timestamp.
  // It is used to check TTL timeouts. It may be inaccurate.
  uint64 current_ts = 5;
}

message TxnCheckTxnStatusResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  // Three kinds of transaction status:
  //   locked: lock_ttl > 0
  //   committed: commit_ts > 0
  //   rollbacked: lock_ttl = 0 && commit_ts = 0
  uint64 lock_ttl = 3;
  // if the transaction of the lock is committed, the commit_ts is returned
  uint64 commit_ts = 4;
  // The action performed by dingo-store (and why if the action is to rollback).
  dingodb.pb.store.Action action = 5;
  dingodb.pb.store.LockInfo lock_info = 6;
}

// For all keys locked by the transaction identified by `start_ts`, either
// commit or rollback the transaction and unlock the key.
message TxnResolveLockRequest {
  dingodb.pb.store.Context context = 1;
  uint64 start_ts = 2;
  // `commit_ts == 0` means the transaction was rolled back.
  // `commit_ts > 0` means the transaction was committed at the given timestamp.
  uint64 commit_ts = 3;
  // Only resolve specified keys.
  repeated bytes keys = 4;
}

message TxnResolveLockResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
}

message TxnBatchGetRequest {
  dingodb.pb.store.Context context = 1;
  repeated bytes keys = 2;
  uint64 version = 3;
}

message TxnBatchGetResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  // When some key is locked but we cannot check locks of
  // all keys. In this case, `kvs` should be empty and the client should redo
  // batch get all the keys after resolving the lock.
  repeated dingodb.pb.common.VectorWithId vectors = 3;
}

// Rollback a prewritten transaction. This will remove the preliminary data from
// the database, unlock locks, and leave a rollback tombstone.
message TxnBatchRollbackRequest {
  dingodb.pb.store.Context context = 1;
  // Identify the transaction to be rolled back.
  uint64 start_ts = 2;
  // The keys to rollback.
  repeated bytes keys = 3;
}

message TxnBatchRollbackResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
}

// Scan the database for locks. Used at the start of the GC process to find all
// old locks.
message TxnScanLockRequest {
  dingodb.pb.store.Context context = 1;
  // Returns all locks with a start timestamp before `max_ts`.
  uint64 max_ts = 2;
  // Start scanning from this key.
  bytes start_key = 3;  // the key is encoded from two uint64 using big-endian, the first uint64 is the part id, the
                        // second uint64 is the vector id. The key MUST be 16 bytes.
  // The maximum number of locks to return.
  uint32 limit = 4;
  // The exclusive upperbound for scanning.
  bytes end_key = 5;
}

message TxnScanLockResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  // Info on all locks found by the scan.
  repeated dingodb.pb.store.LockInfo locks = 3;
}

// Update the lock_ttl of a large transaction to
// prevent it from been killed.
message TxnHeartBeatRequest {
  dingodb.pb.store.Context context = 1;
  // The key of the lock to update.
  bytes primary_lock = 2;
  // Start timestamp of the large transaction.
  uint64 start_ts = 3;
  // The new TTL the sender would like.
  uint64 advise_lock_ttl = 4;
}

message TxnHeartBeatResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  // The TTL actually set on the requested lock.
  uint64 lock_ttl = 3;
}

// Request dingo-store to garbage collect all non-current data older than `safe_point_ts`.
message TxnGcRequest {
  dingodb.pb.store.Context context = 1;
  uint64 safe_point_ts = 2;
}

message TxnGcResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
}

message TxnDumpRequest {
  dingodb.pb.store.Context context = 1;
  bytes key = 2;
  uint64 start_ts = 3;
  uint64 end_ts = 4;
}

message TxnDumpResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnErrorInfo txn_error = 2;
  repeated dingodb.pb.store.TxnWriteKey keys = 3;
  repeated dingodb.pb.store.TxnWriteValue values = 4;
  repeated dingodb.pb.store.TxnLockKey lock_keys = 5;
  repeated dingodb.pb.store.TxnLockValue lock_values = 6;
  repeated dingodb.pb.store.TxnDataKey data_keys = 7;
  repeated dingodb.pb.store.TxnDataValue data_values = 8;
}

service IndexService {
  // vector index
  rpc VectorAdd(VectorAddRequest) returns (VectorAddResponse);
  rpc VectorBatchQuery(VectorBatchQueryRequest) returns (VectorBatchQueryResponse);
  rpc VectorSearch(VectorSearchRequest) returns (VectorSearchResponse);
  rpc VectorDelete(VectorDeleteRequest) returns (VectorDeleteResponse);
  rpc VectorGetBorderId(VectorGetBorderIdRequest) returns (VectorGetBorderIdResponse);
  rpc VectorScanQuery(VectorScanQueryRequest) returns (VectorScanQueryResponse);
  rpc VectorGetRegionMetrics(VectorGetRegionMetricsRequest) returns (VectorGetRegionMetricsResponse);
  rpc VectorCalcDistance(VectorCalcDistanceRequest) returns (VectorCalcDistanceResponse);

  // debug
  // test  vector search performance
  rpc VectorSearchDebug(VectorSearchDebugRequest) returns (VectorSearchDebugResponse);

  // txn rpcs
  rpc TxnGet(TxnGetRequest) returns (TxnGetResponse);
  rpc TxnScan(TxnScanRequest) returns (TxnScanResponse);
  rpc TxnPrewrite(TxnPrewriteRequest) returns (TxnPrewriteResponse);
  rpc TxnCommit(TxnCommitRequest) returns (TxnCommitResponse);
  rpc TxnCheckTxnStatus(TxnCheckTxnStatusRequest) returns (TxnCheckTxnStatusResponse);
  rpc TxnResolveLock(TxnResolveLockRequest) returns (TxnResolveLockResponse);
  rpc TxnBatchGet(TxnBatchGetRequest) returns (TxnBatchGetResponse);
  rpc TxnBatchRollback(TxnBatchRollbackRequest) returns (TxnBatchRollbackResponse);
  rpc TxnScanLock(TxnScanLockRequest) returns (TxnScanLockResponse);
  rpc TxnHeartBeat(TxnHeartBeatRequest) returns (TxnHeartBeatResponse);
  rpc TxnGc(TxnGcRequest) returns (TxnGcResponse);
  rpc TxnDump(TxnDumpRequest) returns (TxnDumpResponse);
};
